- Exception handling is one of the worst sources of complexity in software systems because code that deals with special conditions is inherently harder to write than code that deals with normal cases. and developer often define exceptions without considering how they will be handled.
- why exceptions add complexity
	- the author uses term exception to refer to any un common condition that alter the normal flow of control in a program. many programming languages include a formal exception mechanism that allows exceptions to be thrown by lower level code and caught by enclosing code. however exceptions can happen without using a formal exception reporting mechanism, such as when a method returns a special value indicating that it didn't complete its normal behaviour. All of these forms of exceptions contribute to complexity.
	- **Exceptions Reasons** - A piece of code may encounter exceptions in several different ways:
		- A caller may provide a argument or config information.
		- An invoked method may not be able to complete a requested operation.
		- network packets may be list or delayed, servers may not respond in a timely fashion.
		- the code may detect bugs internal inconsistencies or situations it is not prepared to handle.
	- when an exception occurs, the programmer can deal with it in two ways each of which can be complicated.
		- the first approach is to move forward and complete the work in progress in spite of the exception.
			- if a network packet lost it can be resent if data is corrupted, perhaps it can be recovered from a redundant copy as perhaps the packet wasn't actually lost but was simply delayed.
		- the second approach is to abort the operation in progress and report the exception upwards
			- however aborting can be complicated because the exception may have occurred at a point where system state is inconsistent the exception handling code must restore consistency, such as by unwinding any changes made before the exception occurred.
	- Exception handling code creates opportunities for more exceptions and to prevent an unending cascade of exceptions the developer must eventually find a way to handle exceptions without introducing more exceptions.
	- Most programmers are taught that it's important to detect any report errors they often interpret this to mean "the more errors detected, the better." which might lead to an over defensive style where anything that looks even a bit suspicious is that increase the complexity of the system.
	- It's tempting to use exceptions to avoid dealing with difficult situations rather than figuring out a clean way to handle it, just throw an exception and punt the problem to the caller.
		- some might argue that this approach empowers callers, since it allows each figuring out what to do for the particular situation, there's a good chance that the caller won't know what to do either.
		- generating an exception in a situation like this just passes the problem to someone else and adds to the system complexity
	- Exceptions thrown by a class are part of its interface; classes with lots of exceptions have a complex interface they are shallower than classes with fewer exceptions. [[shallow modules]]
	- An Exception is a particularly complex element of an interface. why? because it can propagate up through several stack levels before being caught so it affects not just the method's caller but potentially also higher-level callers thus the complexity of an exception comes from the exception handling code.
	- the best way to reduce complexity damage caused by exception handling is to reduce the number of places where exceptions have to be handled
- FOUR TECHNIQUES FOR REDUCING THE NUMBER OF EXCEPTION HANDLERS
	- define errors out of existence
		- the best way to eliminate exception handling complexity is to define your APIs so that there are no exceptions to handle: define errors out of existence. this may seem sinful, but it is very effective in practice. consider TCL `uset` command instead of throwing error when unset asked to delete an unknown variable, it should have simply returned without doing anything.
		- with the first definition, unset can't do its job if the variable doesn't exist so generating an exception makes sense. with the second definition, it is perfectly natural for un set to be invoked with the name of a variable that doesn't exist. in this case it's work is already done, so it can simply return there is no longer an error case to report.
	- mask exceptions
		- [[exception masking]]
	- exception aggregation
		- [[exception aggregation]]
		-
	- just crash?
	-